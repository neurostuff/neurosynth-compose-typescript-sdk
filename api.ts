/* tslint:disable */
/* eslint-disable */
/**
 * Analysis Specification for Meta-analysis
 * api to create a meta-analysis specification
 *
 * The version of the OpenAPI document: 1.0
 * Contact: jamesdkent21@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * a holder/reference to the annotation on neurostore
 */
export interface Annotation {
    /**
     * the id of the annotation on neurostore
     */
    'neurostore_id'?: string;
    /**
     * the snapshot taken of the annotation pending a successful run of the meta-analytic algorithm
     */
    'snapshot'?: object | null;
    /**
     * The related cached studyset to this annotation.
     */
    'studyset'?: string;
    'neurostore_url'?: string;
}
export interface AnnotationList {
    'results'?: Array<AnnotationReturn>;
    'metadata'?: object;
}
export interface AnnotationPostBody {
    'cached_studyset_id'?: string;
    /**
     * the id of the annotation on neurostore
     */
    'neurostore_id'?: string;
    /**
     * the snapshot taken of the annotation pending a successful run of the meta-analytic algorithm
     */
    'snapshot'?: object | null;
    /**
     * The related cached studyset to this annotation.
     */
    'studyset'?: string;
    'neurostore_url'?: string;
}
export interface AnnotationReturn {
    /**
     * the id of the annotation on neurostore
     */
    'neurostore_id'?: string;
    /**
     * the snapshot taken of the annotation pending a successful run of the meta-analytic algorithm
     */
    'snapshot'?: object | null;
    /**
     * The related cached studyset to this annotation.
     */
    'studyset'?: string;
    'neurostore_url'?: string;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
export interface AnnotationUpdate {
    /**
     * the id of the annotation on neurostore
     */
    'neurostore_id'?: string;
    /**
     * the snapshot taken of the annotation pending a successful run of the meta-analytic algorithm
     */
    'snapshot'?: object | null;
    /**
     * The related cached studyset to this annotation.
     */
    'studyset'?: string;
    'neurostore_url'?: string;
    'cached_studyset_id'?: string;
}
/**
 * The function/class applying statistical adjustments to the output of the meta-analysis (optional).
 */
export interface Corrector {
    /**
     * the name of the function/class performing the correction. For example FWECorrector from NiMARE would be valid.
     */
    'type'?: string;
    /**
     * key word arguments passed to the corrector to modidy default functionality, such as number of iterations, or the particular method of correction being applied.
     */
    'args'?: object;
}
/**
 * the specification for the function/class running the meta-analysis
 */
export interface Estimator {
    /**
     * the meta-analytic algorithm applied to the data. Currently this should be directly tied to the function/class running the meta-analysis. For example, ALE, or MKDADensity are valid NiMARE classes to put here.
     */
    'type'?: string;
    /**
     * arbitrary keyword arguments to be passed into the function/class to modify default functionality, this could modify the kernel, resampling methods, or any other behavior defined in the function/class (like MKDADensity).
     */
    'args'?: object;
}
export interface MetaAnalysesGet400Response {
    'detail'?: string;
    'status'?: number;
    'title'?: string;
    'type'?: string;
}
/**
 * The combination of the specification determining what meta-analysis to run (required), the studyset to act as input to the meta-analytic algorithm (required), and the annotation to provide human readable annotations as well as acts as an optional filter on which analyses to select within the studyset (optional, but suggested).
 */
export interface MetaAnalysis {
    'specification'?: MetaAnalysisSpecification;
    'studyset'?: MetaAnalysisStudyset;
    'annotation'?: MetaAnalysisAnnotation;
    /**
     * Human-readable name of the meta-analysis.
     */
    'name'?: string | null;
    /**
     * Long form description of the meta-analysis.
     */
    'description'?: string | null;
    /**
     * whether the meta-analysis is public or private
     */
    'public'?: boolean;
    'tags'?: MetaAnalysisTags;
    /**
     * The id of the studyset on neurosynth-compose (as opposed to the id of the studyset on neurostore). Multiple snapshots of the studyset can be stored on neurosynth-compose so knowing which snapshot is being referenced is necessary.
     */
    'cached_studyset_id'?: string;
    /**
     * The id of the annotation on neurosynth-compose (as opposed to the id of the annotation on neurostore). Multiple snapshots of the annotation can be stored on neurosynth-compose so knowing which snapshot is being referenced is necessary.
     */
    'cached_annotation_id'?: string;
    'results'?: MetaAnalysisResults;
    'provenance'?: object | null;
    'project'?: string | null;
    /**
     * a special key used to upload the results of this meta analysis. Can be used as an alternative to using your auth token from login. 
     */
    'run_key'?: string;
    'neurostore_analysis'?: NeurostoreAnalysis;
    'cognitive_contrast_cogatlas'?: string | null;
    'cognitive_contrast_cogatlas_id'?: string | null;
    'cognitive_paradigm_cogatlas'?: string | null;
    'cognitive_paradigm_cogatlas_id'?: string | null;
    'cached_studyset'?: string | null;
    'cached_annotation'?: string | null;
    'neurostore_url'?: string | null;
}
/**
 * @type MetaAnalysisAnnotation
 */
export type MetaAnalysisAnnotation = Annotation | string;

export interface MetaAnalysisJobList {
    'results'?: Array<MetaAnalysisJobResponse>;
    'metadata'?: MetaAnalysisJobListMetadata;
}
export interface MetaAnalysisJobListMetadata {
    /**
     * Number of jobs in the response.
     */
    'count'?: number;
}
export interface MetaAnalysisJobLog {
    /**
     * Epoch timestamp returned by the compose runner.
     */
    'timestamp'?: number;
    /**
     * Log message emitted by the compose runner.
     */
    'message'?: string;
}
export interface MetaAnalysisJobRequest {
    /**
     * Identifier of the meta-analysis to submit.
     */
    'meta_analysis_id': string;
    /**
     * Skip upload of results to Neurostore/Neurovault.
     */
    'no_upload'?: boolean;
}
export interface MetaAnalysisJobResponse {
    /**
     * Identifier returned by the compose runner service.
     */
    'job_id'?: string;
    /**
     * Identifier of the meta-analysis that was submitted.
     */
    'meta_analysis_id'?: string;
    /**
     * Artifact key prefix for logs and outputs.
     */
    'artifact_prefix'?: string;
    /**
     * Latest known status reported by the compose runner.
     */
    'status'?: string;
    /**
     * Convenience URL for polling job status.
     */
    'status_url'?: string | null;
    /**
     * Deployment environment the job was submitted to.
     */
    'environment'?: string;
    /**
     * Indicates whether the upload step was skipped.
     */
    'no_upload'?: boolean;
    /**
     * Start time reported by the compose runner status endpoint.
     */
    'start_time'?: string | null;
    /**
     * Raw output payload returned by the compose runner.
     */
    'output'?: { [key: string]: any; } | null;
    /**
     * Aggregated log events returned by the compose runner.
     */
    'logs'?: Array<MetaAnalysisJobLog>;
    /**
     * Timestamp when the job entry was cached.
     */
    'created_at'?: string | null;
    /**
     * Timestamp when the job entry was last refreshed.
     */
    'updated_at'?: string | null;
}
export interface MetaAnalysisList {
    'results'?: Array<MetaAnalysisReturn>;
    'metadata'?: object;
}
export interface MetaAnalysisPostBody {
    'specification'?: MetaAnalysisSpecification;
    'studyset'?: MetaAnalysisStudyset;
    'annotation'?: MetaAnalysisAnnotation;
    /**
     * Human-readable name of the meta-analysis.
     */
    'name'?: string | null;
    /**
     * Long form description of the meta-analysis.
     */
    'description'?: string | null;
    /**
     * whether the meta-analysis is public or private
     */
    'public'?: boolean;
    'tags'?: MetaAnalysisTags;
    /**
     * The id of the studyset on neurosynth-compose (as opposed to the id of the studyset on neurostore). Multiple snapshots of the studyset can be stored on neurosynth-compose so knowing which snapshot is being referenced is necessary.
     */
    'cached_studyset_id'?: string;
    /**
     * The id of the annotation on neurosynth-compose (as opposed to the id of the annotation on neurostore). Multiple snapshots of the annotation can be stored on neurosynth-compose so knowing which snapshot is being referenced is necessary.
     */
    'cached_annotation_id'?: string;
    'results'?: MetaAnalysisResults;
    'provenance'?: object | null;
    'project'?: string | null;
    /**
     * a special key used to upload the results of this meta analysis. Can be used as an alternative to using your auth token from login. 
     */
    'run_key'?: string;
    'neurostore_analysis'?: NeurostoreAnalysis;
    'cognitive_contrast_cogatlas'?: string | null;
    'cognitive_contrast_cogatlas_id'?: string | null;
    'cognitive_paradigm_cogatlas'?: string | null;
    'cognitive_paradigm_cogatlas_id'?: string | null;
    'cached_studyset'?: string | null;
    'cached_annotation'?: string | null;
    'neurostore_url'?: string | null;
}
/**
 * @type MetaAnalysisResults
 * array of neurostore ids representing the results of this meta-analysis (nominally all results should be the same, but machine architecture differences/algorithm stochastic-ness may lead to slightly different outcomes for each result.
 */
export type MetaAnalysisResults = Array<ResultReturn> | Array<string>;

export interface MetaAnalysisReturn {
    'specification'?: MetaAnalysisSpecification;
    'studyset'?: MetaAnalysisStudyset;
    'annotation'?: MetaAnalysisAnnotation;
    /**
     * Human-readable name of the meta-analysis.
     */
    'name'?: string | null;
    /**
     * Long form description of the meta-analysis.
     */
    'description'?: string | null;
    /**
     * whether the meta-analysis is public or private
     */
    'public'?: boolean;
    'tags'?: MetaAnalysisTags;
    /**
     * The id of the studyset on neurosynth-compose (as opposed to the id of the studyset on neurostore). Multiple snapshots of the studyset can be stored on neurosynth-compose so knowing which snapshot is being referenced is necessary.
     */
    'cached_studyset_id'?: string;
    /**
     * The id of the annotation on neurosynth-compose (as opposed to the id of the annotation on neurostore). Multiple snapshots of the annotation can be stored on neurosynth-compose so knowing which snapshot is being referenced is necessary.
     */
    'cached_annotation_id'?: string;
    'results'?: MetaAnalysisResults;
    'provenance'?: object | null;
    'project'?: string | null;
    /**
     * a special key used to upload the results of this meta analysis. Can be used as an alternative to using your auth token from login. 
     */
    'run_key'?: string;
    'neurostore_analysis'?: NeurostoreAnalysis;
    'cognitive_contrast_cogatlas'?: string | null;
    'cognitive_contrast_cogatlas_id'?: string | null;
    'cognitive_paradigm_cogatlas'?: string | null;
    'cognitive_paradigm_cogatlas_id'?: string | null;
    'cached_studyset'?: string | null;
    'cached_annotation'?: string | null;
    'neurostore_url'?: string | null;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
/**
 * @type MetaAnalysisSpecification
 */
export type MetaAnalysisSpecification = Specification | string;

/**
 * @type MetaAnalysisStudyset
 */
export type MetaAnalysisStudyset = Studyset | string;

/**
 * @type MetaAnalysisTags
 * Tags associated with this meta-analysis (use tag names or tag IDs).
 */
export type MetaAnalysisTags = Array<Tag> | Array<string>;

export interface NeurostoreAnalysis {
    'neurostore_id'?: string | null;
    'exception'?: string | null;
    'traceback'?: string | null;
    'status'?: string | null;
}
export interface NeurostoreStudy {
    'neurostore_id'?: string | null;
    'analyses'?: Array<NeurostoreAnalysis>;
    'exception'?: string | null;
    'traceback'?: string | null;
    'status'?: string | null;
}
export interface NeurostoreStudyList {
    'results'?: Array<NeurostoreStudyReturn>;
    'metadata'?: object;
}
export interface NeurostoreStudyReturn {
    'neurostore_id'?: string | null;
    'analyses'?: Array<NeurostoreAnalysis>;
    'exception'?: string | null;
    'traceback'?: string | null;
    'status'?: string | null;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
export interface NeurovaultCollection {
    'collection_id'?: string | null;
    'files'?: NeurovaultCollectionFiles;
    'url'?: string | null;
}
/**
 * @type NeurovaultCollectionFiles
 */
export type NeurovaultCollectionFiles = Array<NeurovaultFile> | Array<string>;

export interface NeurovaultCollectionReturn {
    'collection_id'?: string | null;
    'files'?: NeurovaultCollectionFiles;
    'url'?: string | null;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
export interface NeurovaultFile {
    'collection_id'?: string | null;
    'exception'?: string | null;
    'traceback'?: string | null;
    'status'?: string;
    'image_id'?: string | null;
    'name'?: string | null;
    'url'?: string | null;
}
export interface NeurovaultFileList {
    'results'?: Array<NeurovaultFileReturn>;
    'metadata'?: object;
}
export interface NeurovaultFileReturn {
    'collection_id'?: string | null;
    'exception'?: string | null;
    'traceback'?: string | null;
    'status'?: string;
    'image_id'?: string | null;
    'name'?: string | null;
    'url'?: string | null;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
export interface NeurovaultList {
    'results'?: Array<NeurovaultCollectionReturn>;
    'metadata'?: object;
}
export interface Project {
    'provenance'?: object | null;
    'meta_analyses'?: ProjectMetaAnalyses;
    'name'?: string | null;
    'description'?: string | null;
    /**
     * whether the project is public or private
     */
    'public'?: boolean;
    'neurostore_study'?: NeurostoreStudy;
    'neurostore_url'?: string | null;
    'draft'?: boolean;
}
export interface ProjectList {
    'results'?: Array<ProjectReturn>;
    'metadata'?: object;
}
/**
 * @type ProjectMetaAnalyses
 */
export type ProjectMetaAnalyses = Array<MetaAnalysis> | Array<string>;

export interface ProjectReturn {
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
    'provenance'?: object | null;
    'meta_analyses'?: ProjectMetaAnalyses;
    'name'?: string | null;
    'description'?: string | null;
    /**
     * whether the project is public or private
     */
    'public'?: boolean;
    'neurostore_study'?: NeurostoreStudy;
    'neurostore_url'?: string | null;
    'draft'?: boolean;
}
export interface ReadOnly {
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
/**
 * describes the output of a meta-analysis
 */
export interface Result {
    /**
     * the meta analysis this result was derived from.
     */
    'meta_analysis_id'?: string;
    /**
     * version of the command-line-tool that is uploading the results. 
     */
    'cli_version'?: string | null;
    'neurovault_collection'?: NeurovaultCollectionReturn;
    /**
     * the description of the methods applied to create this result.
     */
    'methods_description'?: string | null;
    /**
     * a text representation of a tsv that marks the contribution of each study to each particular cluster.
     */
    'diagnostic_table'?: string | null;
    /**
     * additional parameters that were passed to the commandline tool at runtime. 
     */
    'cli_args'?: object | null;
    'status'?: string | null;
}
export interface ResultInit {
    'meta_analysis_id'?: string;
    'studyset_snapshot'?: object;
    'annotation_snapshot'?: object;
    'cli_version'?: string;
}
export interface ResultList {
    'results'?: ResultListResults;
    'metadata'?: object;
}
/**
 * @type ResultListResults
 */
export type ResultListResults = Array<ResultReturn> | Array<string>;

export interface ResultReturn {
    /**
     * the meta analysis this result was derived from.
     */
    'meta_analysis_id'?: string;
    /**
     * version of the command-line-tool that is uploading the results. 
     */
    'cli_version'?: string | null;
    'neurovault_collection'?: NeurovaultCollectionReturn;
    /**
     * the description of the methods applied to create this result.
     */
    'methods_description'?: string | null;
    /**
     * a text representation of a tsv that marks the contribution of each study to each particular cluster.
     */
    'diagnostic_table'?: string | null;
    /**
     * additional parameters that were passed to the commandline tool at runtime. 
     */
    'cli_args'?: object | null;
    'status'?: string | null;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
/**
 * @type ResultUploadStatisticalMaps
 */
export type ResultUploadStatisticalMaps = Array<File> | File;

/**
 * a machine readable specification of how to run a meta-analysis (currently specifically tailored to NiMARE).
 */
export interface Specification {
    /**
     * the type of meta-analysis being run, typically either cbma or ibma, but others may become available in the future.
     */
    'type'?: string;
    'estimator'?: Estimator;
    /**
     * a string representing a binary nifti file to select which voxels a user wants to include in the analysis.
     */
    'mask'?: string | null;
    'conditions'?: SpecificationConditions;
    'weights'?: Array<number> | null;
    /**
     * A transformation applied to column(s) (e.g., binarize based on a threshold). This is likely to become deprecated.
     */
    'transformer'?: string | null;
    'corrector'?: Corrector | null;
    /**
     * a column from annotations selecting which analyses to include in the meta-analysis
     */
    'filter'?: string | null;
    'database_studyset'?: string | null;
}
/**
 * @type SpecificationConditions
 * selection of categories in the filter column to differentiate groups, or \"neurosynth\", \"neuroquery\", or \"neurostore\" to compare to a database reference group
 */
export type SpecificationConditions = Array<boolean> | Array<string>;

/**
 * The representation of a list of specifications.
 */
export interface SpecificationList {
    'results'?: Array<SpecificationReturn>;
    'metadata'?: object;
}
export interface SpecificationPostBody {
    /**
     * the type of meta-analysis being run, typically either cbma or ibma, but others may become available in the future.
     */
    'type'?: string;
    'estimator'?: Estimator;
    /**
     * a string representing a binary nifti file to select which voxels a user wants to include in the analysis.
     */
    'mask'?: string | null;
    'conditions'?: SpecificationConditions;
    'weights'?: Array<number> | null;
    /**
     * A transformation applied to column(s) (e.g., binarize based on a threshold). This is likely to become deprecated.
     */
    'transformer'?: string | null;
    'corrector'?: Corrector | null;
    /**
     * a column from annotations selecting which analyses to include in the meta-analysis
     */
    'filter'?: string | null;
    'database_studyset'?: string | null;
}
/**
 * The view of the specification through an endpoint.
 */
export interface SpecificationReturn {
    /**
     * the type of meta-analysis being run, typically either cbma or ibma, but others may become available in the future.
     */
    'type'?: string;
    'estimator'?: Estimator;
    /**
     * a string representing a binary nifti file to select which voxels a user wants to include in the analysis.
     */
    'mask'?: string | null;
    'conditions'?: SpecificationConditions;
    'weights'?: Array<number> | null;
    /**
     * A transformation applied to column(s) (e.g., binarize based on a threshold). This is likely to become deprecated.
     */
    'transformer'?: string | null;
    'corrector'?: Corrector | null;
    /**
     * a column from annotations selecting which analyses to include in the meta-analysis
     */
    'filter'?: string | null;
    'database_studyset'?: string | null;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
export interface Studyset {
    /**
     * The id of the studyset on neurostore.
     */
    'neurostore_id'?: string;
    /**
     * The snapshot of the studyset pending a successful run of the meta-analysis.
     */
    'snapshot'?: object | null;
    'neurostore_url'?: string;
    /**
     * A string representing a labeled version of this particular studyset.
     */
    'version'?: string | null;
}
export interface StudysetList {
    'results'?: Array<StudysetReturn>;
    'metadata'?: object;
}
export interface StudysetPostBody {
    /**
     * The id of the studyset on neurostore.
     */
    'neurostore_id'?: string;
    /**
     * The snapshot of the studyset pending a successful run of the meta-analysis.
     */
    'snapshot'?: object | null;
    'neurostore_url'?: string;
    /**
     * A string representing a labeled version of this particular studyset.
     */
    'version'?: string | null;
}
export interface StudysetReference {
    'snapshots'?: Array<StudysetReferenceSnapshotsInner>;
}
export interface StudysetReferenceList {
    'results'?: Array<StudysetReferenceReturn>;
    'metadata'?: object;
}
export interface StudysetReferenceReturn {
    'snapshots'?: Array<StudysetReferenceSnapshotsInner>;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
/**
 * @type StudysetReferenceSnapshotsInner
 */
export type StudysetReferenceSnapshotsInner = Studyset | string;

export interface StudysetReturn {
    /**
     * The id of the studyset on neurostore.
     */
    'neurostore_id'?: string;
    /**
     * The snapshot of the studyset pending a successful run of the meta-analysis.
     */
    'snapshot'?: object | null;
    'neurostore_url'?: string;
    /**
     * A string representing a labeled version of this particular studyset.
     */
    'version'?: string | null;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
/**
 * A user-scoped or global label that can be attached to multiple resources. Tag groups are free-form categories (e.g., \"visibility\", \"topic\") used to segment tags across different resource types.
 */
export interface Tag {
    /**
     * Case-insensitive unique name within the tag scope (user or global).
     */
    'name': string;
    /**
     * Optional grouping key to categorize tags (case-insensitive exact match in queries).
     */
    'group'?: string | null;
    'description'?: string | null;
    'official'?: boolean | null;
}
export interface TagList {
    'results'?: Array<TagReturn>;
    'metadata'?: object;
}
export interface TagReturn {
    /**
     * Case-insensitive unique name within the tag scope (user or global).
     */
    'name': string;
    /**
     * Optional grouping key to categorize tags (case-insensitive exact match in queries).
     */
    'group'?: string | null;
    'description'?: string | null;
    'official'?: boolean | null;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}
/**
 * attributes of the user object
 */
export interface User {
    'external_id'?: string;
}
export interface UserList {
    'results'?: Array<UserReturn>;
    'metadata'?: object;
}
export interface UserReturn {
    'external_id'?: string;
    /**
     * the identifier for the resource.
     */
    'id'?: string;
    /**
     * when the resource was last modified.
     */
    'updated_at'?: string | null;
    /**
     * When the resource was created.
     */
    'created_at'?: string;
    /**
     * Who owns the resource.
     */
    'user'?: string | null;
    'username'?: string | null;
}

/**
 * AnnotationsApi - axios parameter creator
 */
export const AnnotationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get a list of serialized/referenced annotations
         * @summary GET a list of annotations
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsGet: async (nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (info !== undefined) {
                localVarQueryParameter['info'] = info;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a single annotation
         * @summary GET information about an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdGet', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an existing annotation
         * @summary Update an Annotation
         * @param {string} id 
         * @param {AnnotationUpdate} [annotationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdPut: async (id: string, annotationUpdate?: AnnotationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdPut', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a new serialized/referenced annotation
         * @summary Create a new Annotation
         * @param {AnnotationPostBody} [annotationPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsPost: async (annotationPostBody?: AnnotationPostBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationPostBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationsApi - functional programming interface
 */
export const AnnotationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnotationsApiAxiosParamCreator(configuration)
    return {
        /**
         * get a list of serialized/referenced annotations
         * @summary GET a list of annotations
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsGet(nested, ids, page, pageSize, search, sort, desc, userId, info, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get a single annotation
         * @summary GET information about an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update an existing annotation
         * @summary Update an Annotation
         * @param {string} id 
         * @param {AnnotationUpdate} [annotationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdPut(id: string, annotationUpdate?: AnnotationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdPut(id, annotationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create a new serialized/referenced annotation
         * @summary Create a new Annotation
         * @param {AnnotationPostBody} [annotationPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsPost(annotationPostBody?: AnnotationPostBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsPost(annotationPostBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnnotationsApi - factory interface
 */
export const AnnotationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnotationsApiFp(configuration)
    return {
        /**
         * get a list of serialized/referenced annotations
         * @summary GET a list of annotations
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationList> {
            return localVarFp.annotationsGet(nested, ids, page, pageSize, search, sort, desc, userId, info, options).then((request) => request(axios, basePath));
        },
        /**
         * get a single annotation
         * @summary GET information about an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationReturn> {
            return localVarFp.annotationsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update an existing annotation
         * @summary Update an Annotation
         * @param {string} id 
         * @param {AnnotationUpdate} [annotationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdPut(id: string, annotationUpdate?: AnnotationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationReturn> {
            return localVarFp.annotationsIdPut(id, annotationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * create a new serialized/referenced annotation
         * @summary Create a new Annotation
         * @param {AnnotationPostBody} [annotationPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsPost(annotationPostBody?: AnnotationPostBody, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationReturn> {
            return localVarFp.annotationsPost(annotationPostBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationsApi - object-oriented interface
 */
export class AnnotationsApi extends BaseAPI {
    /**
     * get a list of serialized/referenced annotations
     * @summary GET a list of annotations
     * @param {boolean} [nested] show nested component instead of id
     * @param {Array<string>} [ids] choose the specific ids you wish to get
     * @param {number} [page] page of results
     * @param {number} [pageSize] number of elements to return on a page
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {string} [userId] user id you want to filter on
     * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public annotationsGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsGet(nested, ids, page, pageSize, search, sort, desc, userId, info, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a single annotation
     * @summary GET information about an annotation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public annotationsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an existing annotation
     * @summary Update an Annotation
     * @param {string} id 
     * @param {AnnotationUpdate} [annotationUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public annotationsIdPut(id: string, annotationUpdate?: AnnotationUpdate, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsIdPut(id, annotationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a new serialized/referenced annotation
     * @summary Create a new Annotation
     * @param {AnnotationPostBody} [annotationPostBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public annotationsPost(annotationPostBody?: AnnotationPostBody, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsPost(annotationPostBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaAnalysesIdDelete', 'id', id)
            const localVarPath = `/meta-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {boolean} [nested] show nested component instead of id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetReferencesGet: async (nested?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studyset-references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [nested] show nested component instead of id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetReferencesIdGet: async (id: string, nested?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studysetReferencesIdGet', 'id', id)
            const localVarPath = `/studyset-references/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaAnalysesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaAnalysesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.metaAnalysesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {boolean} [nested] show nested component instead of id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetReferencesGet(nested?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReferenceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetReferencesGet(nested, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.studysetReferencesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [nested] show nested component instead of id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetReferencesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReferenceReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetReferencesIdGet(id, nested, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.studysetReferencesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metaAnalysesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {boolean} [nested] show nested component instead of id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetReferencesGet(nested?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReferenceList> {
            return localVarFp.studysetReferencesGet(nested, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [nested] show nested component instead of id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetReferencesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReferenceReturn> {
            return localVarFp.studysetReferencesIdGet(id, nested, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metaAnalysesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).metaAnalysesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {boolean} [nested] show nested component instead of id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public studysetReferencesGet(nested?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).studysetReferencesGet(nested, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {boolean} [nested] show nested component instead of id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public studysetReferencesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).studysetReferencesIdGet(id, nested, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetaAnalysesApi - axios parameter creator
 */
export const MetaAnalysesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * list all runnable specification, studyset, annotation bundles
         * @summary GET a list of meta-analyses
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [description] search description field for a term
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysesGet: async (nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, name?: string, search?: string, description?: string, sort?: string, desc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/meta-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a meta-analysis (specification, annotation, and studyset)
         * @summary GET meta-analysis information
         * @param {string} id 
         * @param {boolean} [nested] show nested component instead of id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysesIdGet: async (id: string, nested?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaAnalysesIdGet', 'id', id)
            const localVarPath = `/meta-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an existing meta-analysis (that has not yet been run)
         * @summary Update a meta-analysis
         * @param {string} id 
         * @param {MetaAnalysis} [metaAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysesIdPut: async (id: string, metaAnalysis?: MetaAnalysis, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaAnalysesIdPut', 'id', id)
            const localVarPath = `/meta-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metaAnalysis, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a new specification, studyset, annotation bundle
         * @summary Create a new meta-analysis
         * @param {MetaAnalysisPostBody} [metaAnalysisPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysesPost: async (metaAnalysisPostBody?: MetaAnalysisPostBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/meta-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metaAnalysisPostBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} [metaAnalysisId] search for results with this meta-analysis id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysisResultsGet: async (metaAnalysisId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/meta-analysis-results`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (metaAnalysisId !== undefined) {
                localVarQueryParameter['meta_analysis_id'] = metaAnalysisId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysisResultsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaAnalysisResultsIdGet', 'id', id)
            const localVarPath = `/meta-analysis-results/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {Result} [result] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysisResultsIdPut: async (id: string, result?: Result, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaAnalysisResultsIdPut', 'id', id)
            const localVarPath = `/meta-analysis-results/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication upload_key required
            await setApiKeyToObject(localVarHeaderParameter, "Compose-Upload-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(result, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {ResultInit} [resultInit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysisResultsPost: async (resultInit?: ResultInit, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/meta-analysis-results`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication upload_key required
            await setApiKeyToObject(localVarHeaderParameter, "Compose-Upload-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resultInit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the most recent status information and logs for a submitted job.
         * @summary Get status and logs for a meta-analysis job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobResourceGet: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobResourceGet', 'jobId', jobId)
            const localVarPath = `/meta-analysis-jobs/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return cached job submissions associated with the authenticated user.
         * @summary List meta-analysis jobs for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourceGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/meta-analysis-jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a meta-analysis to the compose runner service.
         * @summary Submit a meta-analysis job
         * @param {MetaAnalysisJobRequest} metaAnalysisJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourcePost: async (metaAnalysisJobRequest: MetaAnalysisJobRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metaAnalysisJobRequest' is not null or undefined
            assertParamExists('neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourcePost', 'metaAnalysisJobRequest', metaAnalysisJobRequest)
            const localVarPath = `/meta-analysis-jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metaAnalysisJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetaAnalysesApi - functional programming interface
 */
export const MetaAnalysesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetaAnalysesApiAxiosParamCreator(configuration)
    return {
        /**
         * list all runnable specification, studyset, annotation bundles
         * @summary GET a list of meta-analyses
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [description] search description field for a term
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaAnalysesGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, name?: string, search?: string, description?: string, sort?: string, desc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetaAnalysisList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaAnalysesGet(nested, ids, page, pageSize, name, search, description, sort, desc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.metaAnalysesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get a meta-analysis (specification, annotation, and studyset)
         * @summary GET meta-analysis information
         * @param {string} id 
         * @param {boolean} [nested] show nested component instead of id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaAnalysesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetaAnalysisReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaAnalysesIdGet(id, nested, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.metaAnalysesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update an existing meta-analysis (that has not yet been run)
         * @summary Update a meta-analysis
         * @param {string} id 
         * @param {MetaAnalysis} [metaAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaAnalysesIdPut(id: string, metaAnalysis?: MetaAnalysis, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetaAnalysisReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaAnalysesIdPut(id, metaAnalysis, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.metaAnalysesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create a new specification, studyset, annotation bundle
         * @summary Create a new meta-analysis
         * @param {MetaAnalysisPostBody} [metaAnalysisPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaAnalysesPost(metaAnalysisPostBody?: MetaAnalysisPostBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetaAnalysisReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaAnalysesPost(metaAnalysisPostBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.metaAnalysesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} [metaAnalysisId] search for results with this meta-analysis id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaAnalysisResultsGet(metaAnalysisId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaAnalysisResultsGet(metaAnalysisId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.metaAnalysisResultsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaAnalysisResultsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaAnalysisResultsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.metaAnalysisResultsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {Result} [result] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaAnalysisResultsIdPut(id: string, result?: Result, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaAnalysisResultsIdPut(id, result, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.metaAnalysisResultsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {ResultInit} [resultInit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaAnalysisResultsPost(resultInit?: ResultInit, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaAnalysisResultsPost(resultInit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.metaAnalysisResultsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the most recent status information and logs for a submitted job.
         * @summary Get status and logs for a meta-analysis job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobResourceGet(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetaAnalysisJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobResourceGet(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobResourceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return cached job submissions associated with the authenticated user.
         * @summary List meta-analysis jobs for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourceGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetaAnalysisJobList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourceGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit a meta-analysis to the compose runner service.
         * @summary Submit a meta-analysis job
         * @param {MetaAnalysisJobRequest} metaAnalysisJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourcePost(metaAnalysisJobRequest: MetaAnalysisJobRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetaAnalysisJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourcePost(metaAnalysisJobRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaAnalysesApi.neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourcePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetaAnalysesApi - factory interface
 */
export const MetaAnalysesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetaAnalysesApiFp(configuration)
    return {
        /**
         * list all runnable specification, studyset, annotation bundles
         * @summary GET a list of meta-analyses
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [description] search description field for a term
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysesGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, name?: string, search?: string, description?: string, sort?: string, desc?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<MetaAnalysisList> {
            return localVarFp.metaAnalysesGet(nested, ids, page, pageSize, name, search, description, sort, desc, options).then((request) => request(axios, basePath));
        },
        /**
         * get a meta-analysis (specification, annotation, and studyset)
         * @summary GET meta-analysis information
         * @param {string} id 
         * @param {boolean} [nested] show nested component instead of id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<MetaAnalysisReturn> {
            return localVarFp.metaAnalysesIdGet(id, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * update an existing meta-analysis (that has not yet been run)
         * @summary Update a meta-analysis
         * @param {string} id 
         * @param {MetaAnalysis} [metaAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysesIdPut(id: string, metaAnalysis?: MetaAnalysis, options?: RawAxiosRequestConfig): AxiosPromise<MetaAnalysisReturn> {
            return localVarFp.metaAnalysesIdPut(id, metaAnalysis, options).then((request) => request(axios, basePath));
        },
        /**
         * create a new specification, studyset, annotation bundle
         * @summary Create a new meta-analysis
         * @param {MetaAnalysisPostBody} [metaAnalysisPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysesPost(metaAnalysisPostBody?: MetaAnalysisPostBody, options?: RawAxiosRequestConfig): AxiosPromise<MetaAnalysisReturn> {
            return localVarFp.metaAnalysesPost(metaAnalysisPostBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} [metaAnalysisId] search for results with this meta-analysis id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysisResultsGet(metaAnalysisId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResultList> {
            return localVarFp.metaAnalysisResultsGet(metaAnalysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysisResultsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ResultReturn> {
            return localVarFp.metaAnalysisResultsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {Result} [result] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysisResultsIdPut(id: string, result?: Result, options?: RawAxiosRequestConfig): AxiosPromise<ResultReturn> {
            return localVarFp.metaAnalysisResultsIdPut(id, result, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {ResultInit} [resultInit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAnalysisResultsPost(resultInit?: ResultInit, options?: RawAxiosRequestConfig): AxiosPromise<ResultReturn> {
            return localVarFp.metaAnalysisResultsPost(resultInit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the most recent status information and logs for a submitted job.
         * @summary Get status and logs for a meta-analysis job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobResourceGet(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<MetaAnalysisJobResponse> {
            return localVarFp.neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobResourceGet(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return cached job submissions associated with the authenticated user.
         * @summary List meta-analysis jobs for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourceGet(options?: RawAxiosRequestConfig): AxiosPromise<MetaAnalysisJobList> {
            return localVarFp.neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourceGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a meta-analysis to the compose runner service.
         * @summary Submit a meta-analysis job
         * @param {MetaAnalysisJobRequest} metaAnalysisJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourcePost(metaAnalysisJobRequest: MetaAnalysisJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<MetaAnalysisJobResponse> {
            return localVarFp.neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourcePost(metaAnalysisJobRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetaAnalysesApi - object-oriented interface
 */
export class MetaAnalysesApi extends BaseAPI {
    /**
     * list all runnable specification, studyset, annotation bundles
     * @summary GET a list of meta-analyses
     * @param {boolean} [nested] show nested component instead of id
     * @param {Array<string>} [ids] choose the specific ids you wish to get
     * @param {number} [page] page of results
     * @param {number} [pageSize] number of elements to return on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [description] search description field for a term
     * @param {string} [sort] Parameter to sort results on
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metaAnalysesGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, name?: string, search?: string, description?: string, sort?: string, desc?: boolean, options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).metaAnalysesGet(nested, ids, page, pageSize, name, search, description, sort, desc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a meta-analysis (specification, annotation, and studyset)
     * @summary GET meta-analysis information
     * @param {string} id 
     * @param {boolean} [nested] show nested component instead of id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metaAnalysesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).metaAnalysesIdGet(id, nested, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an existing meta-analysis (that has not yet been run)
     * @summary Update a meta-analysis
     * @param {string} id 
     * @param {MetaAnalysis} [metaAnalysis] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metaAnalysesIdPut(id: string, metaAnalysis?: MetaAnalysis, options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).metaAnalysesIdPut(id, metaAnalysis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a new specification, studyset, annotation bundle
     * @summary Create a new meta-analysis
     * @param {MetaAnalysisPostBody} [metaAnalysisPostBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metaAnalysesPost(metaAnalysisPostBody?: MetaAnalysisPostBody, options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).metaAnalysesPost(metaAnalysisPostBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {string} [metaAnalysisId] search for results with this meta-analysis id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metaAnalysisResultsGet(metaAnalysisId?: string, options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).metaAnalysisResultsGet(metaAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metaAnalysisResultsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).metaAnalysisResultsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} id 
     * @param {Result} [result] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metaAnalysisResultsIdPut(id: string, result?: Result, options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).metaAnalysisResultsIdPut(id, result, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {ResultInit} [resultInit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metaAnalysisResultsPost(resultInit?: ResultInit, options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).metaAnalysisResultsPost(resultInit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the most recent status information and logs for a submitted job.
     * @summary Get status and logs for a meta-analysis job
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobResourceGet(jobId: string, options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobResourceGet(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return cached job submissions associated with the authenticated user.
     * @summary List meta-analysis jobs for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourceGet(options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourceGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a meta-analysis to the compose runner service.
     * @summary Submit a meta-analysis job
     * @param {MetaAnalysisJobRequest} metaAnalysisJobRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourcePost(metaAnalysisJobRequest: MetaAnalysisJobRequest, options?: RawAxiosRequestConfig) {
        return MetaAnalysesApiFp(this.configuration).neurosynthComposeResourcesMetaAnalysisJobsMetaAnalysisJobsResourcePost(metaAnalysisJobRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Your GET endpoint
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [description] search description field for a term
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGet: async (page?: number, pageSize?: number, name?: string, search?: string, description?: string, sort?: string, desc?: boolean, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsIdDelete', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdGet: async (id: string, info?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsIdGet', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (info !== undefined) {
                localVarQueryParameter['info'] = info;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {boolean} [syncMetaAnalysesPublic] when updating a project\&#39;s public flag, also set each child meta-analysis to the same public value
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdPut: async (id: string, syncMetaAnalysesPublic?: boolean, project?: Project, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsIdPut', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (syncMetaAnalysesPublic !== undefined) {
                localVarQueryParameter['sync_meta_analyses_public'] = syncMetaAnalysesPublic;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} [sourceId] clone an existing project when creating a new project
         * @param {boolean} [copyAnnotations] when cloning via &#x60;source_id&#x60;, also duplicate associated annotations
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPost: async (sourceId?: string, copyAnnotations?: boolean, project?: Project, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            if (copyAnnotations !== undefined) {
                localVarQueryParameter['copy_annotations'] = copyAnnotations;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Your GET endpoint
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [description] search description field for a term
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGet(page?: number, pageSize?: number, name?: string, search?: string, description?: string, sort?: string, desc?: boolean, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGet(page, pageSize, name, search, description, sort, desc, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsIdGet(id: string, info?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsIdGet(id, info, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {boolean} [syncMetaAnalysesPublic] when updating a project\&#39;s public flag, also set each child meta-analysis to the same public value
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsIdPut(id: string, syncMetaAnalysesPublic?: boolean, project?: Project, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsIdPut(id, syncMetaAnalysesPublic, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} [sourceId] clone an existing project when creating a new project
         * @param {boolean} [copyAnnotations] when cloning via &#x60;source_id&#x60;, also duplicate associated annotations
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsPost(sourceId?: string, copyAnnotations?: boolean, project?: Project, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsPost(sourceId, copyAnnotations, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Your GET endpoint
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [description] search description field for a term
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGet(page?: number, pageSize?: number, name?: string, search?: string, description?: string, sort?: string, desc?: boolean, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectList> {
            return localVarFp.projectsGet(page, pageSize, name, search, description, sort, desc, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdGet(id: string, info?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ProjectReturn> {
            return localVarFp.projectsIdGet(id, info, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {boolean} [syncMetaAnalysesPublic] when updating a project\&#39;s public flag, also set each child meta-analysis to the same public value
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdPut(id: string, syncMetaAnalysesPublic?: boolean, project?: Project, options?: RawAxiosRequestConfig): AxiosPromise<ProjectReturn> {
            return localVarFp.projectsIdPut(id, syncMetaAnalysesPublic, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} [sourceId] clone an existing project when creating a new project
         * @param {boolean} [copyAnnotations] when cloning via &#x60;source_id&#x60;, also duplicate associated annotations
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPost(sourceId?: string, copyAnnotations?: boolean, project?: Project, options?: RawAxiosRequestConfig): AxiosPromise<ProjectReturn> {
            return localVarFp.projectsPost(sourceId, copyAnnotations, project, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Your GET endpoint
     * @param {number} [page] page of results
     * @param {number} [pageSize] number of elements to return on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [description] search description field for a term
     * @param {string} [sort] Parameter to sort results on
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {string} [userId] user id you want to filter on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsGet(page?: number, pageSize?: number, name?: string, search?: string, description?: string, sort?: string, desc?: boolean, userId?: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsGet(page, pageSize, name, search, description, sort, desc, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsIdGet(id: string, info?: boolean, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsIdGet(id, info, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} id 
     * @param {boolean} [syncMetaAnalysesPublic] when updating a project\&#39;s public flag, also set each child meta-analysis to the same public value
     * @param {Project} [project] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsIdPut(id: string, syncMetaAnalysesPublic?: boolean, project?: Project, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsIdPut(id, syncMetaAnalysesPublic, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} [sourceId] clone an existing project when creating a new project
     * @param {boolean} [copyAnnotations] when cloning via &#x60;source_id&#x60;, also duplicate associated annotations
     * @param {Project} [project] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsPost(sourceId?: string, copyAnnotations?: boolean, project?: Project, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsPost(sourceId, copyAnnotations, project, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SpecificationsApi - axios parameter creator
 */
export const SpecificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * list of meta-analysis specifications
         * @summary Get a list of Specifications
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specificationsGet: async (nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/specifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (info !== undefined) {
                localVarQueryParameter['info'] = info;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a meta-analysis specification
         * @summary Get information about a Specification
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specificationsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('specificationsIdGet', 'id', id)
            const localVarPath = `/specifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an existing meta analysis specification
         * @summary Update Meta-Analysis specification
         * @param {string} id 
         * @param {Specification} [specification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specificationsIdPut: async (id: string, specification?: Specification, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('specificationsIdPut', 'id', id)
            const localVarPath = `/specifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(specification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a new meta-analysis specification
         * @summary Create a Specification
         * @param {SpecificationPostBody} [specificationPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specificationsPost: async (specificationPostBody?: SpecificationPostBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/specifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(specificationPostBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpecificationsApi - functional programming interface
 */
export const SpecificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpecificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * list of meta-analysis specifications
         * @summary Get a list of Specifications
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async specificationsGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecificationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.specificationsGet(nested, ids, page, pageSize, search, sort, desc, userId, info, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecificationsApi.specificationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get a meta-analysis specification
         * @summary Get information about a Specification
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async specificationsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecificationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.specificationsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecificationsApi.specificationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update an existing meta analysis specification
         * @summary Update Meta-Analysis specification
         * @param {string} id 
         * @param {Specification} [specification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async specificationsIdPut(id: string, specification?: Specification, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecificationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.specificationsIdPut(id, specification, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecificationsApi.specificationsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create a new meta-analysis specification
         * @summary Create a Specification
         * @param {SpecificationPostBody} [specificationPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async specificationsPost(specificationPostBody?: SpecificationPostBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecificationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.specificationsPost(specificationPostBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecificationsApi.specificationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SpecificationsApi - factory interface
 */
export const SpecificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpecificationsApiFp(configuration)
    return {
        /**
         * list of meta-analysis specifications
         * @summary Get a list of Specifications
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specificationsGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SpecificationList> {
            return localVarFp.specificationsGet(nested, ids, page, pageSize, search, sort, desc, userId, info, options).then((request) => request(axios, basePath));
        },
        /**
         * get a meta-analysis specification
         * @summary Get information about a Specification
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specificationsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SpecificationReturn> {
            return localVarFp.specificationsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update an existing meta analysis specification
         * @summary Update Meta-Analysis specification
         * @param {string} id 
         * @param {Specification} [specification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specificationsIdPut(id: string, specification?: Specification, options?: RawAxiosRequestConfig): AxiosPromise<SpecificationReturn> {
            return localVarFp.specificationsIdPut(id, specification, options).then((request) => request(axios, basePath));
        },
        /**
         * create a new meta-analysis specification
         * @summary Create a Specification
         * @param {SpecificationPostBody} [specificationPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specificationsPost(specificationPostBody?: SpecificationPostBody, options?: RawAxiosRequestConfig): AxiosPromise<SpecificationReturn> {
            return localVarFp.specificationsPost(specificationPostBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpecificationsApi - object-oriented interface
 */
export class SpecificationsApi extends BaseAPI {
    /**
     * list of meta-analysis specifications
     * @summary Get a list of Specifications
     * @param {boolean} [nested] show nested component instead of id
     * @param {Array<string>} [ids] choose the specific ids you wish to get
     * @param {number} [page] page of results
     * @param {number} [pageSize] number of elements to return on a page
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {string} [userId] user id you want to filter on
     * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public specificationsGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options?: RawAxiosRequestConfig) {
        return SpecificationsApiFp(this.configuration).specificationsGet(nested, ids, page, pageSize, search, sort, desc, userId, info, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a meta-analysis specification
     * @summary Get information about a Specification
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public specificationsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return SpecificationsApiFp(this.configuration).specificationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an existing meta analysis specification
     * @summary Update Meta-Analysis specification
     * @param {string} id 
     * @param {Specification} [specification] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public specificationsIdPut(id: string, specification?: Specification, options?: RawAxiosRequestConfig) {
        return SpecificationsApiFp(this.configuration).specificationsIdPut(id, specification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a new meta-analysis specification
     * @summary Create a Specification
     * @param {SpecificationPostBody} [specificationPostBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public specificationsPost(specificationPostBody?: SpecificationPostBody, options?: RawAxiosRequestConfig) {
        return SpecificationsApiFp(this.configuration).specificationsPost(specificationPostBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StudysetsApi - axios parameter creator
 */
export const StudysetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get a list of serialized/referenced studysets
         * @summary Get a list of Studysets
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsGet: async (nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studysets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (info !== undefined) {
                localVarQueryParameter['info'] = info;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a single serialized/referenced studyset
         * @summary Get information about a Studyset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studysetsIdGet', 'id', id)
            const localVarPath = `/studysets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an existing serialized/referenced studyset
         * @summary Update a Studyset
         * @param {string} id 
         * @param {Studyset} [studyset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdPut: async (id: string, studyset?: Studyset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studysetsIdPut', 'id', id)
            const localVarPath = `/studysets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a new serialized/referenced studyset
         * @summary Create a new Studyset
         * @param {StudysetPostBody} [studysetPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsPost: async (studysetPostBody?: StudysetPostBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studysets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studysetPostBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudysetsApi - functional programming interface
 */
export const StudysetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudysetsApiAxiosParamCreator(configuration)
    return {
        /**
         * get a list of serialized/referenced studysets
         * @summary Get a list of Studysets
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsGet(nested, ids, page, pageSize, search, sort, desc, userId, info, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudysetsApi.studysetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get a single serialized/referenced studyset
         * @summary Get information about a Studyset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudysetsApi.studysetsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update an existing serialized/referenced studyset
         * @summary Update a Studyset
         * @param {string} id 
         * @param {Studyset} [studyset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsIdPut(id: string, studyset?: Studyset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsIdPut(id, studyset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudysetsApi.studysetsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create a new serialized/referenced studyset
         * @summary Create a new Studyset
         * @param {StudysetPostBody} [studysetPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsPost(studysetPostBody?: StudysetPostBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsPost(studysetPostBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudysetsApi.studysetsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudysetsApi - factory interface
 */
export const StudysetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudysetsApiFp(configuration)
    return {
        /**
         * get a list of serialized/referenced studysets
         * @summary Get a list of Studysets
         * @param {boolean} [nested] show nested component instead of id
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StudysetList> {
            return localVarFp.studysetsGet(nested, ids, page, pageSize, search, sort, desc, userId, info, options).then((request) => request(axios, basePath));
        },
        /**
         * get a single serialized/referenced studyset
         * @summary Get information about a Studyset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReturn> {
            return localVarFp.studysetsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update an existing serialized/referenced studyset
         * @summary Update a Studyset
         * @param {string} id 
         * @param {Studyset} [studyset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdPut(id: string, studyset?: Studyset, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReturn> {
            return localVarFp.studysetsIdPut(id, studyset, options).then((request) => request(axios, basePath));
        },
        /**
         * create a new serialized/referenced studyset
         * @summary Create a new Studyset
         * @param {StudysetPostBody} [studysetPostBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsPost(studysetPostBody?: StudysetPostBody, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReturn> {
            return localVarFp.studysetsPost(studysetPostBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudysetsApi - object-oriented interface
 */
export class StudysetsApi extends BaseAPI {
    /**
     * get a list of serialized/referenced studysets
     * @summary Get a list of Studysets
     * @param {boolean} [nested] show nested component instead of id
     * @param {Array<string>} [ids] choose the specific ids you wish to get
     * @param {number} [page] page of results
     * @param {number} [pageSize] number of elements to return on a page
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {string} [userId] user id you want to filter on
     * @param {boolean} [info] display additional information about a nested relationship without displaying fully nested object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public studysetsGet(nested?: boolean, ids?: Array<string>, page?: number, pageSize?: number, search?: string, sort?: string, desc?: boolean, userId?: string, info?: boolean, options?: RawAxiosRequestConfig) {
        return StudysetsApiFp(this.configuration).studysetsGet(nested, ids, page, pageSize, search, sort, desc, userId, info, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a single serialized/referenced studyset
     * @summary Get information about a Studyset
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public studysetsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return StudysetsApiFp(this.configuration).studysetsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an existing serialized/referenced studyset
     * @summary Update a Studyset
     * @param {string} id 
     * @param {Studyset} [studyset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public studysetsIdPut(id: string, studyset?: Studyset, options?: RawAxiosRequestConfig) {
        return StudysetsApiFp(this.configuration).studysetsIdPut(id, studyset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a new serialized/referenced studyset
     * @summary Create a new Studyset
     * @param {StudysetPostBody} [studysetPostBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public studysetsPost(studysetPostBody?: StudysetPostBody, options?: RawAxiosRequestConfig) {
        return StudysetsApiFp(this.configuration).studysetsPost(studysetPostBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of Tags
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [filter] alias for search when filtering tags
         * @param {string} [description] search description field for a term
         * @param {string} [group] filter tags by group
         * @param {boolean} [official] filter tags by official flag
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet: async (ids?: Array<string>, page?: number, pageSize?: number, name?: string, search?: string, filter?: string, description?: string, group?: string, official?: boolean, sort?: string, desc?: boolean, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (official !== undefined) {
                localVarQueryParameter['official'] = official;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about a Tag
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagsIdGet', 'id', id)
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Tag
         * @param {Tag} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost: async (tag?: Tag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of Tags
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [filter] alias for search when filtering tags
         * @param {string} [description] search description field for a term
         * @param {string} [group] filter tags by group
         * @param {boolean} [official] filter tags by official flag
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsGet(ids?: Array<string>, page?: number, pageSize?: number, name?: string, search?: string, filter?: string, description?: string, group?: string, official?: boolean, sort?: string, desc?: boolean, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsGet(ids, page, pageSize, name, search, filter, description, group, official, sort, desc, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about a Tag
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Tag
         * @param {Tag} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsPost(tag?: Tag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsPost(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of Tags
         * @param {Array<string>} [ids] choose the specific ids you wish to get
         * @param {number} [page] page of results
         * @param {number} [pageSize] number of elements to return on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [filter] alias for search when filtering tags
         * @param {string} [description] search description field for a term
         * @param {string} [group] filter tags by group
         * @param {boolean} [official] filter tags by official flag
         * @param {string} [sort] Parameter to sort results on
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {string} [userId] user id you want to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(ids?: Array<string>, page?: number, pageSize?: number, name?: string, search?: string, filter?: string, description?: string, group?: string, official?: boolean, sort?: string, desc?: boolean, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<TagList> {
            return localVarFp.tagsGet(ids, page, pageSize, name, search, filter, description, group, official, sort, desc, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about a Tag
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TagReturn> {
            return localVarFp.tagsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Tag
         * @param {Tag} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost(tag?: Tag, options?: RawAxiosRequestConfig): AxiosPromise<TagReturn> {
            return localVarFp.tagsPost(tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of Tags
     * @param {Array<string>} [ids] choose the specific ids you wish to get
     * @param {number} [page] page of results
     * @param {number} [pageSize] number of elements to return on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [filter] alias for search when filtering tags
     * @param {string} [description] search description field for a term
     * @param {string} [group] filter tags by group
     * @param {boolean} [official] filter tags by official flag
     * @param {string} [sort] Parameter to sort results on
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {string} [userId] user id you want to filter on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagsGet(ids?: Array<string>, page?: number, pageSize?: number, name?: string, search?: string, filter?: string, description?: string, group?: string, official?: boolean, sort?: string, desc?: boolean, userId?: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsGet(ids, page, pageSize, name, search, filter, description, group, official, sort, desc, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about a Tag
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Tag
     * @param {Tag} [tag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagsPost(tag?: Tag, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsPost(tag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all users
         * @summary GET list of Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get User Info by User ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update information about a user
         * @summary Update User Information
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut: async (id: string, user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdPut', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a single user
         * @summary Create A New User
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * List all users
         * @summary GET list of Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get User Info by User ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update information about a user
         * @summary Update User Information
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdPut(id: string, user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdPut(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create a single user
         * @summary Create A New User
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * List all users
         * @summary GET list of Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: RawAxiosRequestConfig): AxiosPromise<UserList> {
            return localVarFp.usersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get User Info by User ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserReturn> {
            return localVarFp.usersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update information about a user
         * @summary Update User Information
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(id: string, user?: User, options?: RawAxiosRequestConfig): AxiosPromise<UserReturn> {
            return localVarFp.usersIdPut(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * create a single user
         * @summary Create A New User
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user?: User, options?: RawAxiosRequestConfig): AxiosPromise<UserReturn> {
            return localVarFp.usersPost(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * List all users
     * @summary GET list of Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersGet(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the information of the user with the matching user ID.
     * @summary Get User Info by User ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update information about a user
     * @summary Update User Information
     * @param {string} id 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersIdPut(id: string, user?: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdPut(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a single user
     * @summary Create A New User
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersPost(user?: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPost(user, options).then((request) => request(this.axios, this.basePath));
    }
}



